package com.stephengware.java.games.chess.bot;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.Random;

import com.stephengware.java.games.chess.bot.Bot;
import com.stephengware.java.games.chess.state.Board;
import com.stephengware.java.games.chess.state.Knight;
import com.stephengware.java.games.chess.state.Pawn;
import com.stephengware.java.games.chess.state.Piece;
import com.stephengware.java.games.chess.state.State;

/**
 * A chess bot which selects its next move at random.
 * 
 * @author Stephen G. Ware
 */
public class smosely1 extends Bot {

	/** A random number generator */
	private final Random random;
	private int maxDepth;
    private Board board;
	
	/**
	 * Constructs a new chess bot named "My Chess Bot" and whose random  number
	 * generator (see {@link java.util.Random}) begins with a seed of 0.
	 */
	public smosely1() {
		super("Klumsy");
		this.random = new Random(0);
		this.maxDepth = maxDepth;
		this.board = board;
	}

	@Override
	protected State chooseMove(State root) {
		// This list will hold all the children nodes of the root.
		ArrayList<State> children = new ArrayList<>();
		// Generate all the children nodes of the root (that is, all the
		// possible next states of the game.  Make sure that we do not exceed
		// the number of GameTree nodes that we are allowed to generate.
		Iterator<State> iterator = root.next().iterator();
		while(!root.searchLimitReached() && iterator.hasNext())
			children.add(iterator.next());
		// Choose one of the children at random.
		return children.get(random.nextInt(children.size()));
	}

	public Move chooseMove() {
        int alpha = Integer.MIN_VALUE;
        int beta = Integer.MAX_VALUE;
        int maxEval = Integer.MIN_VALUE;
        Move bestMove = null;
        for (Move move : board.legalMoves()) {
            board.doMove(move);
            int eval = miniMax(maxDepth - 1, alpha, beta, board, false);
            board.undoMove();
            if (eval > maxEval) {
                maxEval = eval;
                bestMove = move;
            }
        }
        return bestMove;
    }


	private int miniMax(int depth, int alpha, int beta, Board board, boolean maxPlayer) {
        if (depth == 0 || board.isDraw() || board.isMated() || board.isStaleMate()) {
            return evaluate(board);
        }

        if (maxPlayer) {
            int maxEval = Integer.MIN_VALUE;
            for (Move move : board.legalMoves()) {
                board.doMove(move);
                int eval = miniMax(depth - 1, alpha, beta, board, false);
                board.undoMove();
                maxEval = Math.max(maxEval, eval);
                alpha = Math.max(alpha, eval);
                if (beta <= alpha) {
                    break;
                }
            }
            return maxEval;

        } else {
            int minEval = Integer.MAX_VALUE;
            for (Move move : board.legalMoves()) {
                board.doMove(move);
                int eval = miniMax(depth - 1, alpha, beta, board, true);
                board.undoMove();
                minEval = Math.min(minEval, eval);
                beta = Math.min(beta, eval);
                if (beta <= alpha) {
                    break;
                }
            }
            return minEval;
        }
    }

    private int evaluate(Board board) {
        int score = 0;
        for (Board boardSquare : Board.values()) {
            Piece piece = board.getPiece(square);
            if (piece != null) {
                int pieceValue = getPieceValue(piece);
                if (piece.getPieceSide() == player.WHITE) {
                    score += pieceValue;
                } else {
                    score -= pieceValue;
                }
            }
        }
        return score;
    }

    private int getPieceValue(Piece piece) {
        switch (piece.getPieceType()) {
            case Pawn.class:
                return 1;
            case Knight.class:
                return 3;
            case BISHOP.class:
                return 3;
            case ROOK.class:
                return 5;
            case QUEEN.class:
                return 9;
            case KING.class:
                return 1000;
            default:
                return 0;
        }
    }
}
