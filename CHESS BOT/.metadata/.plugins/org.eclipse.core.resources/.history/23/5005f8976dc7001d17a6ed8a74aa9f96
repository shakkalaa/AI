package com.stephengware.java.games.chess.bot;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.Random;

//import javax.swing.plaf.nimbus.State;

//import com.stephengware.java.games.chess.state.Player;
//import com.stephengware.java.games.chess.state.State;
import com.stephengware.java.games.chess.*;
import com.stephengware.java.games.chess.state.*;


/**
 * A chess bot which selects its next move at random.
 * 
 * @author Stephen G. Ware
 * 
 */
public class smosely1 extends Bot {

	private final Random random;
	private Player player = null;

	
	
	public smosely1(){
		super("klumsykay");
		this.random = new Random(0);
	}
	
	/**@Override
	protected State (State root) {
		// This list will hold all the children nodes of the root.
		ArrayList<State> children = new ArrayList<>();
		// Generate all the children nodes of the root (that is, all the
		// possible next states of the game.  Make sure that we do not exceed
		// the number of GameTree nodes that we are allowed to generate.
		Iterator<State> iterator = root.next().iterator();
		while(!root.searchLimitReached() && iterator.hasNext())
			children.add(iterator.next());
		// Choose one of the children at random.
		return children.get(random.nextInt(children.size()));
	}*/
    /**
     * 
     * 
     * @author Stephen G.Ware
     * @return 
     */

	@Override
	protected State chooseMove(State root) {
		System.out.println(root.player.name());

		if (player == null) {
			player = root.player;
		}

		return minMax(root);
	}

	public State minMax(State state) {
		GameTree root = new GameTree(state);

		double value;

		if (state.player.name() == player.name()) {
			value = findMax(root);
		}else{
			value = findMin(root);
		}

		for(GameTree child : root.children){
			if (child.value == value) {
				
				return child.state;
			}
			//return null;
		}
		return null;
	}

	private double findMax(GameTree tree){
		double maximum = Double.NEGATIVE_INFINITY;

		if (!tree.hasNextChild()) {
			try {
				return Utility.gameStatus(tree.state, player);
			} catch (Exception e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}

		while (tree.hasNextChild()) {
			GameTree child = tree.getNextChild();
			child.value = findMin(child);

			maximum = Math.max(maximum, child.value);
		}

		return maximum;
	}

	private double findMin(GameTree tree){
		double minimum = Double.POSITIVE_INFINITY;

		if (!tree.hasNextChild()) {
			try {
				return Utility.gameStatus(tree.state, player);
			} catch (Exception e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}

		while (tree.hasNextChild()) {
			GameTree child = tree.getNextChild();
			child.value = findMax(child);

			minimum = Math.min(child.value, minimum);
		}

		return minimum;
	}
	
	class GameTree{
		public final State state;
		public double value = 0;

		public final ArrayList<GameTree> children = new ArrayList<>();

		private final Iterator<State> nextMove;

		protected GameTree(State state){
			this.state = state;
			this.nextMove = state.next().iterator();
		}

		/**@return number of nodes
		 * 
		 */

		public int size(){
			int size = 1;
			
			for (GameTree child : children) {
				size+= child.size();

				
			}
			
			return size;
		}

		/**@return true if more children nodes havent been expanded
		 * 
		 */

		public boolean hasNextChild(){
			if(!state.searchLimitReached() && nextMove.hasNext()){
				return true;
			}
			return false;
		}

		/**@return next child node
		 * 
		 */
		public GameTree getNextChild(){
			State childState = nextMove.next();
			GameTree child = new GameTree(childState);
			children.add(child);
			return child;
		}
	}

	public class Utility{

		/** @param state the current of game
		 * @return a positive/ negative number/zero
		 * 
		 */

		public static double gameStatus(State state, Player player){
			if (state.player != player) {
				System.out.println(state.player.name());
			}

			if (state.over) {
				if (state.check) {
					if (state.player == player) {
						return -1;
					}
					else{
						return 1;
					}
				}else {
					return 0;
				}
				
				
			}else{
				int totalPieces = state.board.countPieces();
				int numPiecesMyBot = state.board.countPieces(player);
				int numPiecesOtherBot = totalPieces - numPiecesMyBot;

				System.out.println(numPiecesMyBot + ", " + numPiecesOtherBot);

				if (numPiecesMyBot > numPiecesOtherBot) {
					return 1;

				} else if (numPiecesMyBot < numPiecesOtherBot) {
					return -1;

				} else {
					return 0;
				} 
					
			}
		}
	}
}


