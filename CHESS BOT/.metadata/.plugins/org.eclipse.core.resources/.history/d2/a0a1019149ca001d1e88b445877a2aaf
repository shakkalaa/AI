package com.stephengware.java.games.chess.bot;

import java.util.*;

import com.stephengware.java.games.chess.bot.*;
import com.stephengware.java.games.chess.state.*;
import com.stephengware.java.games.chess.util.*;



/**
 * A chess bot which selects its next move at random.
 * 
 * @author Stephen G. Ware
 */
public class smosely1 extends Bot {

	/** A random number generator */
	private int maxDepth;


	
	/**
	 * Constructs a new chess bot named "My Chess Bot" and whose random  number
	 * generator (see {@link java.util.Random}) begins with a seed of 0.
	 */
	public smosely1() {
		super("Klumsy");
		this.maxDepth = maxDepth;
	}

	/*
	@Override
	protected State chooseMove(State root) {
		// This list will hold all the children nodes of the root.
		ArrayList<State> children = new ArrayList<>();
		// Generate all the children nodes of the root (that is, all the
		// possible next states of the game.  Make sure that we do not exceed
		// the number of GameTree nodes that we are allowed to generate.
		Iterator<State> iterator = root.next().iterator();
		while(!root.searchLimitReached() && iterator.hasNext())
			children.add(iterator.next());
		// Choose one of the children at random.
		return children.get(random.nextInt(children.size()));
	}*/

	@Override
	public Move chooseMove(State state) {
		int alpha = Integer.MIN_VALUE;
        int beta = Integer.MAX_VALUE;
        int maxEval = Integer.MIN_VALUE;
        Move bestMove = null;
        for (Move move : state.moves()) {
            state.applyMove(move);
            int eval = miniMax(maxDepth - 1, alpha, beta, state, false);
            state.undoMove();
            if (eval > maxEval) {
                maxEval = eval;
                bestMove = move;
            }
        }
        return bestMove;
    }


	private int miniMax(int depth, int alpha, int beta, State state, boolean maxPlayer) {
		 if (depth == 0 || state.isDraw() || state.isMated() || state.isStalemate()) {
	            return evaluate(state);
	        }

	        if (maxPlayer) {
	            int maxEval = Integer.MIN_VALUE;
	            for (Move move : state.moves()) {
	                state.applyMove(move);
	                int eval = miniMax(depth - 1, alpha, beta, state, false);
	                state.undoMove();
	                maxEval = Math.max(maxEval, eval);
	                alpha = Math.max(alpha, eval);
	                if (beta <= alpha) {
	                    break;
	                }
	            }
	            return maxEval;
	        } else {
	            int minEval = Integer.MAX_VALUE;
	            for (Move move : state.moves()) {
	                state.applyMove(move);
	                int eval = miniMax(depth - 1, alpha, beta, state, true);
	                state.undoMove();
	                minEval = Math.min(minEval, eval);
	                beta = Math.min(beta, eval);
	                if (beta <= alpha) {
	                    break;
	                }
	            }
	            return minEval;
	        }
    }

	private int evaluateState(State state) {
        int score = 0;
        for (int rank = 0; rank < 8; rank++) {
            for (int file = 0; file < 8; file++) {
                Piece piece = state.getPiece(rank, file);
                if (piece != null) {
                    int pieceValue = getPieceValue(piece);
                    if (piece.getSide() == Side.WHITE) {
                        score += pieceValue;
                    } else {
                        score -= pieceValue;
                    }
                }
            }
        }
        return score;
    }

	private int getPieceValue(Piece piece) {
        switch (piece.getType()) {
            case PAWN.class:
                return 1;
            case KNIGHT.class:
                return 3;
            case BISHOP.class:
                return 3;
            case ROOK.class:
                return 5;
            case QUEEN.class:
                return 9;
            case KING.class:
                return 1000;
            default:
                return 0;
        }
    }
}