package edu.uno.ai.sat.ex;

import java.util.ArrayList;
import java.util.Random;

import edu.uno.ai.sat.Assignment;
import edu.uno.ai.sat.Clause;
import edu.uno.ai.sat.Literal;
import edu.uno.ai.sat.Solver;
import edu.uno.ai.sat.Value;
import edu.uno.ai.sat.Variable;
import edu.uno.ai.util.ImmutableArray;

/**
 * 
 * @author Your Name
 */
public class Smosely extends Solver {

	private final Random random = new Random(0);
	
	/**
	 * Constructs a new random SAT solver. You should change the string below
	 * from "random" to your ID. You should also change the name of this class.
	 * In Eclipse, you can do that easily by right-clicking on this file
	 * (RandomAgent.java) in the Package Explorer and choosing Refactor > Rename.
	 */
	public Smosely() {
		super("smosely1");
		
	}

	@Override
	public boolean solve(Assignment assignment) {
		// If the problem has no variables, it is trivially true or false.
		if(assignment.problem.variables.size() == 0)
			return assignment.getValue() == Value.TRUE;
		else {
			// Keep trying until the assignment is satisfying.
			
			return WALKSAT(assignment);				    
				//if we've gotten to this point, it means we've tried every single possible combination and nothing has worked thus far.
				//Either we ran out of operations, or the problem is, indeed, unsolvable.
				//either way, return false.
				
			}
		}
	
	
	private double countIf(Assignment a, Variable var){
//		Let val be the current value of var in assignment a.
		Value val = a.getValue(var);
		int original = a.countFalseClauses();
		
		
//		Let opp be the opposite of val (if val is T then opp is F; if val is F then opp is T).
		Value opp = val.negate();
//		Set var to opp in a.
		a.setValue(var, opp);
//		Let n be the number of false clauses.
		int changed = a.countFalseClauses();
//		Set var to val.
		
		if(changed < original) {
			return 0;
		}
		a.setValue(var, val);	
		double totalClauses = a.countFalseClauses() + a.countTrueClauses();
		double n1 = changed/totalClauses;
		
		
		return n1;
	}
	
	//Local search method
	private boolean GSAT(Assignment assignment) {
		double n;
		for(Variable var: assignment.problem.variables) {
			if(assignment.getValue(var) == Value.UNKNOWN) {
				assignment.setValue(var, Value.FALSE);
			}
		}
		boolean time = true;
		//Until time runs out.
		while(time) {
			if(assignment.getValue() == Value.TRUE) {
				return true;
			}
		
			Variable subject = chooseVariable(assignment);
			n = countIf(assignment, subject);
			
			Value original = assignment.getValue(subject);
//			System.out.println(n);
			if(.5 < n ) { // with probability p < n:
				assignment.setValue(subject, original.negate());
				//flip the variable that leads to higher utility
			}
			else {
				Variable myVariable = chooseVariable(assignment);
				Value myValue = assignment.getValue(myVariable);
				
				assignment.setValue(myVariable, myValue.negate());
				//flip a random variable
			}
		}
		return false;
	}
	
	private final Variable chooseVariableinClause(Clause clause) {
		// This list will hold all variables whose current value is 'unknown.'
		ArrayList<Variable> unknown = new ArrayList<>();
		// Loop through all the variables in the problem and find ones whose
		// current value is 'unknown.'
		for(Literal l : clause.literals)
			unknown.add(l.variable);
		// If any variables are 'unknown,' choose one of them randomly.
		if(unknown.size() > 0)
			return unknown.get(random.nextInt(unknown.size()));
		// Otherwise, choose any variable from the problem at random.
		else
			return clause.problem.variables.get(random.nextInt(clause.problem.variables.size()));
	}
	
	//Local search method
		private boolean WALKSAT(Assignment assignment) {
			double n;
			
			ImmutableArray<Variable> variables = assignment.problem.variables;
			
			for(Variable var: variables) {
				if(assignment.getValue(var) == Value.UNKNOWN) {
					assignment.setValue(var, Value.FALSE);
					//Possible to make true in beginning or interchange between true and false
				}
			}
			boolean time = true;
			//Until time runs out.
			while(time) {
				double p = random.nextDouble();
				if(assignment.getValue() == Value.TRUE) {
					return true;
				}
				
				ImmutableArray<Clause> clauses = assignment.problem.clauses;
				//just pick one clause, no need to loop through all of them
				for( Clause clause: clauses) {
					
					if(assignment.getValue(clause) == Value.FALSE) {
						for(Literal literal: clause.literals) {
							n = countIf(assignment, literal.variable);
							Value original = assignment.getValue(literal.variable);
//							System.out.println(n);
							if(p < n ) { // with probability p < n:
								assignment.setValue(literal.variable, original.negate());
								//flip the variable that leads to higher utility
							}
							
							else if(p == n) {
								Variable myVariable = chooseVariableinClause(clause);
								
								Value myValue = assignment.getValue(myVariable);
								if(countIf(assignment, myVariable) > 0) {
									assignment.setValue(myVariable, myValue.negate());
								}
							}
							else {
								int i = 0;
								while(i < 3) {
									//use while loop to adjust amount of pure symbol checks
									Variable myVariable = chooseVariableinClause(clause);
									//use pure symbol logic to make an educated guess at a good variable to swap.
									if(myVariable == Find_Pure_Symbol(clauses, myVariable, assignment)) {
										if(countIf(assignment, myVariable) > 0) {
											Value winner = assignment.getValue(myVariable);
											assignment.setValue(myVariable, winner.negate());
										}
									}
									i++;
								}
								
								//after 3 attempts just find another variable that may make a change.
								Variable myVariable = chooseVariableinClause(clause);
								
								Value myValue = assignment.getValue(myVariable);
								if(countIf(assignment, myVariable) > 0) {
									assignment.setValue(myVariable, myValue.negate());
								}
								
								//flip a random variable
							}
						}
					}
				}
				
				
//				
//				Variable subject = chooseVariable(assignment);
//				n = countIf(assignment, subject);
//				Value original = assignment.getValue(subject);
//				System.out.println(n);
//				if(0.5 < n) { // with probability p < n:
//					assignment.setValue(subject, original.negate());
//					//flip the variable that leads to higher utility
//				}
//				else {
//					Variable myVariable = chooseVariable(assignment);
//					Value myValue = assignment.getValue(myVariable);
//					
//					assignment.setValue(myVariable, myValue.negate());
//					//flip a random variable
//				}
			}
			return false;
		}
	
	/**
	 * Randomly choose a variable from the problem whose value will be set. If
	 * any variables have the value 'unknown,' choose one of those first;
	 * otherwise choose any variable.
	 * 
	 * @param assignment the assignment being worked on
	 * @return a variable, chosen randomly
	 */
	private final Variable chooseVariable(Assignment assignment) {
		// This list will hold all variables whose current value is 'unknown.'
		ArrayList<Variable> unknown = new ArrayList<>();
		// Loop through all the variables in the problem and find ones whose
		// current value is 'unknown.'
		for(Variable variable : assignment.problem.variables)
			if(assignment.getValue(variable) == Value.UNKNOWN)
				unknown.add(variable);
		// If any variables are 'unknown,' choose one of them randomly.
		if(unknown.size() > 0)
			return unknown.get(random.nextInt(unknown.size()));
		// Otherwise, choose any variable from the problem at random.
		else
			return assignment.problem.variables.get(random.nextInt(assignment.problem.variables.size()));
	}
	
	//Set a variable to a value, and if it doesn’t work, undo it. 
	private boolean tryValue(Assignment a, Variable var, Value val){ 
	    //Back up the variable’s current value. 
	    Value backup = a.getValue(var); 
	    //Set the variable to the given value. 
	    a.setValue(var, val); 
	    //Try to solve the problem with this new information. 
	    if(solver1(a)){ 
	    	return true; 
	    } 
	  //If we failed to solve the problem, return the variable to its previous value. 
	    else{ 
	    	a.setValue(var, backup); 
	    	return false; 
	   	} 
	 }
	
	
//	private boolean DPLL_SATISFIABLE(Assignment assignment) {
//		return DPLL(assignment.problem.clauses, assignment.problem.variables, assignment);
//	}
//	
//	private boolean DPLL(ImmutableArray<Clause> clauses, ImmutableArray<Variable> variables, Assignment assignment) {
//		boolean c = true;
//		
////		if every clause in clauses is true in model then return true
////		if some clause in clauses is false in model then return false
//		for(Clause clause: clauses) {
//			if(assignment.getValue(clause) == Value.FALSE) {
//				c = false;
//				return false;
//			}
//		}
//		if(c) {
//			return true;
//		}
//		//P, value = FIND-PURE-SYMBOL(symbols, clauses, model)
//		Variable pureSymbol = Find_Pure_Symbol(clauses, variables, assignment);
//		
////		if P is non-null then return DPLL(clauses, symbols – P, model and {P=value})
//		if(pureSymbol != null) {
//			if(tryValue(assignment, pureSymbol, Value.TRUE)){
//				return DPLL(clauses, variables, assignment);
//			}
//			if(tryValue(assignment, pureSymbol, Value.FALSE)) {
//				return DPLL(clauses, variables, assignment);
//			}
//			
//		}
//		
////		Variable UnitSymbol = Find_Unit_Clause(clauses, assignment);
//		
//		return c;
//
////		P, value = FIND-UNIT-CLAUSE(clauses, model)
////		if P is non-null then return DPLL(clauses, symbols – P, model and {P=value})
////		P = FIRST(symbols); rest = REST(symbols)
////		return DPLL(clauses, rest, model and {P=true}) or
////		DPLL(clauses, rest, model and {P=false}))
//	}
	
	private Variable Find_Unit_Clause(ImmutableArray<Clause> clauses, Assignment assignment) {
		Variable p = null;
		for(Clause clause: clauses) {
			return p;
		}
		return p;
	}
	
	private Variable Find_Pure_Symbol(ImmutableArray<Clause> clauses, Variable variable, Assignment assignment) {
		Variable p = variable;
		
		boolean isPure = true;
		boolean firstVar = variable.literals.get(0).valence;
		for(Literal pure: variable.literals) {
				
			if(pure.valence != firstVar) {
				isPure = false;
				break;
			}
		}
		if(isPure == true) {
				
			return p;
		}
			
		
		return null;
	}
	
	private boolean solver1(Assignment assignment) {
//		Begin with every variable’s value unassigned.
		if(assignment.getValue() == Value.TRUE) {
			return true;
		}
		for(Variable variable : assignment.problem.variables) {
			if(assignment.getValue(variable) == Value.UNKNOWN) {
				
//				To find a model which satisfies a CNF expression:
//				    If every clause is true, return true.
					if(assignment.getValue() == Value.TRUE) {
						return true;
					}
//					if(DPLL_SATISFIABLE(assignment)) {
//						return true;
//					}
//				    If any clause is empty, return false.
//				    Choose an unassigned variable V.
//					Variable v = chooseVariable(assignment);
					
//				    Set V=T. Try to find a model that satisfies.
					boolean satisfiable = tryValue(assignment, variable, Value.TRUE);
					if(satisfiable == true) {
						return true;
					}
					
//				    Set V=F. Try to find a model that satisfies.
					satisfiable = tryValue(assignment, variable, Value.FALSE);
					if(satisfiable == true) {
						return true;
					}
					
					
				}
		}

//		    Simplify the model using unit propagation.
//		    Simplify the model using pure symbols.




		    return false;
		
	}
	
	
}


