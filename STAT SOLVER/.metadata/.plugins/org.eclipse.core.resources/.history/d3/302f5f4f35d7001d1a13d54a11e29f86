package edu.uno.ai.sat.ex;

import java.util.ArrayList;
import java.util.Random;
import java.util.*;

import edu.uno.ai.sat.Assignment;
import edu.uno.ai.sat.Solver;
import edu.uno.ai.sat.Value;
import edu.uno.ai.sat.Variable;
import edu.uno.ai.sat.*;

public class Smosely extends Solver {

    private final Random random = new Random(0);

    public Smosely() {
        super("smosely1");
    }

    @Override
    public boolean solve(Assignment assignment) {
    	
        // If the problem has no variables, it is trivially true or false.
        if (assignment.problem.variables.size() == 0)
            return assignment.getValue() == Value.TRUE;
        
        else {
            // Keep trying until the assignment is satisfying.
            while (assignment.getValue() != Value.TRUE) {
                
            	// Perform unit propagation
                while (unitPropagation(assignment)) {

                	// Perform pure literal elimination
                	pureLiteralElimination(assignment);

                	// Choose a variable whose value will be set using a heuristic
                	Variable variable = chooseVariable(assignment);

                	// Choose 'true' or 'false' for the variable using a heuristic
                	Value value = chooseValue(variable, assignment);

                	// Assign the chosen value to the chosen variable.
                	assignment.setValue(variable, value);

                	// Check if the maximum number of operations or time limit has been reached
                	if (getOperationCount() >= 100000 || getTimeElapsed() >= 300000) {
                		return false;
                	}
                }	
            }
            // Return success. (Note, if the problem cannot be solved, this
            // solver will run until it reaches the operations or time limit.)
            return true;
        }
    }

    /**
     * Perform unit propagation by assigning the value of any variable that
     * appears in a clause with all other variables assigned except for one.
     * 
     * @param assignment the assignment being worked on
     * @return true if any assignments were made, false otherwise
     */
    private final boolean unitPropagation(Assignment assignment) {
        boolean assignmentMade = false;
        for (Variable variable : assignment.problem.variables) {
            if (assignment.getValue(variable) == Value.UNKNOWN) {
                ArrayList<Variable> unassignedVariables = new ArrayList<>();
                Value unassignedValue = Value.UNKNOWN;
                for (int i = 0; i < variable.problem.clauses.size(); i++) {
                    int unknownCount = 0;
                    Variable unknownVariable = null;
                    for (Variable v : variable.problem.clauses.get(i).variables) {
                        Value value = assignment.getValue(v);
                        if (value == Value.UNKNOWN) {
                            unknownCount++;
                            unknownVariable = v;
                        } else if (value == Value.TRUE) {
                            unknownCount = -1;
                            break;
                        }
                    }
                    if (unknownCount == 1) {
                        unassignedVariables.add(unknownVariable);
                        unassignedValue = variable.problem.clauses.get(i).getValue(unknownVariable);
                    } else if (unknownCount == 0) {
                        if (variable.problem.clauses.get(i).getValue(variable) == Value.TRUE) {
                            assignment.setValue(variable, Value.TRUE);
                            assignmentMade = true;
                            break;
                        }
                    }
                }
                if (unassignedVariables.size() == 1) {
                    assignment.setValue(unassignedVariables.get(0), unassignedValue);
                    assignmentMade = true;
                    break;
                }
            }
        }
        return assignmentMade;
    }

    /**
     * Perform pure literal elimination by assigning the value of any variable
     * that appears only with one polarity in the entire formula.
     * 
     * @param assignment theassignment being worked on
*/
private final void pureLiteralElimination(Assignment assignment) {
	for (Variable variable : assignment.problem.variables) {
		if (assignment.getValue(variable) == Value.UNKNOWN) {
			boolean hasPositive = false;
			boolean hasNegative = false;
			
			for (int i = 0; i < variable.problem.clauses.size(); i++) {
				if (variable.clauses.get(i).getValue(variable) == Value.TRUE) {
					hasPositive = true;
				} else {
					hasNegative = true;
				}
			}
			if (hasPositive && !hasNegative) {
				assignment.setValue(variable, Value.TRUE);
			} else if (hasNegative && !hasPositive) {
				assignment.setValue(variable, Value.FALSE);
			}
		}
		}
	}
	/**
* Choose a variable to be assigned next, using the Jeroslow-Wang heuristic.
*
* @param assignment the assignment being worked on
* @return the chosen variable
*/
	private final Variable chooseVariable(Assignment assignment) {
	
		// Compute the Jeroslow-Wang score for each variable.
		double[] scores = new double[assignment.problem.variables.size()];
		for (Variable variable : assignment.problem.variables) {
			if (assignment.getValue(variable) == Value.UNKNOWN) {
				double score = 0;
				for (int i = 0; i < variable.clauses.size(); i++) {
					score += Math.pow(2, -variable.clauses.get(i).countUnknown());
				}
				scores[variable.index] = score;
			}
		}
	    // Choose the variable with the highest score.
		double maxScore = Double.NEGATIVE_INFINITY;
		Variable chosenVariable = null;
		for (Variable variable : assignment.problem.variables) {
			if (assignment.getValue(variable) == Value.UNKNOWN && scores[variable.index] > maxScore) {
				maxScore = scores[variable.index];
				chosenVariable = variable;
			}
		}
	
		return chosenVariable;
	
	}	
	/**
	 * Choose a value to be assigned to the given variable, using the
	 * random-walk heuristic.
	 * 
	 * @param variable the variable being assigned
	 * @param assignment the assignment being worked on
	 * @return the chosen value
	 */
	
	private final Value chooseValue(Variable variable, Assignment assignment) {
		int trueCount = 0;
		int falseCount = 0;
		for (int i = 0; i < variable.problem.clauses.size(); i++) {
			Value value = variable.problem.clauses.get(i).getValue(variable);
			if (value == Value.TRUE) {
				trueCount++;
			} else if (value == Value.FALSE) {
				falseCount++;
			}
		}
		
	
		if (trueCount > falseCount) {
			return Value.FALSE;
		} else if (falseCount > trueCount) {
			return Value.TRUE;
		} else {
			return random.nextBoolean() ? Value.TRUE : Value.FALSE;
		}
	}
}